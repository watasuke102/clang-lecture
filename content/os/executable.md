---
title: "実行形式ファイルができるまで"
date: 2022-06-08T11:36:21+09:00
draft: true
---

## 前提知識

この章は、C 言語をある程度理解してから読んだほうが良いかもしれません。

- C 言語のファイル分割に関する知識
- ELF

## 導入

C 言語でプログラムを記述し、clang や gcc にそれを渡すことによって、実行形式ファイルを得ることが出来ます。それでは、clang や gcc は何をしてくれているのでしょうか？このページでは、コンパイラ及びリンカの働きを見ていきます。

## Transition phases

C 言語において、ソースコードが実行形式ファイルになるまでの流れを `Transition phases` と呼びます（仕様書 5.1.1.2）。大まかな流れでいうと、以下のような手順を踏みます：

1. マルチバイト文字・代替演算子の置き換え  
   ソースコードに含まれる文字を `source character set` と呼ばれる、基本的な英数字と記号に置き換えます。例えば、改行文字・マルチバイト文字・代替演算子などが置き換えられます。
2. バックスラッシュと改行が連続している部分を結合
   この書き方は微妙に分かりづらいですが、例えば、複数行に渡るマクロを書く際に文末にバックスラッシュを入れたりしますよね？これらが置き換えられます。さらに、以下のようなコードも置き換えられます。

```c
pr\
int\
f("Hello\n");
// after: printf(“Hello\n”);
```

3. プリプロセッサ用のトークンを生成
   例えば `#include` におけるヘッダ名など、プリプロセッサのためのトークンが生成されます。
4. プリプロセッサの実行
   先ほど生成したトークンをもとに、`#include` によるファイルの展開などが行われます。展開されたファイルに対してもここまで紹介してきた処理が行われます。
5. 文字および文字列のマッピング
   文字定数と文字列リテラル内の文字およびエスケープシーケンスが `execution character set` と呼ばれる文字セットに置き換えられます。
6. 文字列リテラルの連結
   C 言語において、2 つ以上の文字列リテラルを並べて書いた際、それらを 1 つの文字列リテラルとして連結して扱うことが出来ます。そのための処理がここで行われます。
7. コンパイルの実行
   いよいよコンパイルです。コンパイラはソースコードを読み、コンパイルを行います。
8. リンクの実行
   リンカは、コンパイル結果をもとに、各環境に適した実行形式ファイルを出力します。

この内、重要なのは最後の 2 つです。ここからは、この 2 つについて学んでいくことにします。

## コンパイラの役割とオブジェクトファイル

コンパイラは、前述の通りソースコードをコンパイルします。とても大まかに言うと、以下のような流れになります：

1. トークンの生成
2. アセンブリや機械語の生成
3. オブジェクトファイルの出力

コンパイルのみが行われたファイルを **オブジェクトファイル** と呼びます。拡張子は `.o` であることが多いです。

この「オブジェクトファイル」はどのような構造をしているのでしょうか？ `file` コマンドで確認してみましょう。

以下のようなプログラム `main.c` および `hello.c` を作成します。なお、ここからの解説はこれら `main.c` と `hello.c` をもとに行うので、必要なタイミングで遡ったりしてください。実際に手元でこれらのファイルを作成して見るとやりやすいかもしれません。

`main.c` には、main関数を記述しています。hello関数の実体はここにはありません。プロトタイプ宣言のみ存在することに注目してください。

```c
// main.c
extern void hello(void);

int main(void) {
  hello();
  return 0;
}
```

`hello.c` には、main関数から呼び出されている `hello` 関数の実体を記述しています。

```c
// hello.c
#include <stdio.h>

void hello() {
  printf("Hello\n");
}
```

それでは、これらをコンパイルしてみましょう。clang に `-c` オプションを渡すことで、オブジェクトファイルを作成してもらうことができます。ついでに、デバッグ情報を追加する `-g` オプションも付けておきます。後々役に立ちます。

ついでなので、これらのオブジェクトファイルを使って実行ファイルも作ってみましょう。後述しますが、ここで行われている作業がリンクです。

```
$ ls
main.c  hello.c
# main.cのコンパイル
$ clang -g -c -o main.o main.c
# hello.cのコンパイル
$ clang -g -c -o hello.o hello.c
$ ls
main.c  main.o  hello.c  hello.o
# 実行ファイルを作成（リンク）
$ clang -g main.o hello.o
$ ls
a.out  main.c  main.o  hello.c  hello.o
$ ./a.out
Hello
# ファイルのフォーマットを確認する
$ file main.o
```

そう、オブジェクトファイルの正体は紛れもなく **`ELF` ファイル**　です。再配置可能、つまりリンク可能なファイルであることがわかります。

ELFであるということは、`readelf` が使えるということです。が、ここでは代わりに `objdump` というコマンドを使ってみます。これを使って、このELFファイルに含まれる機械語を逆アセンブルしてみましょう。

`objdump` に `-d` オプションを付与することによって、逆アセンブルされたアセンブリを閲覧できます。今回は `main.o` を見てみます。

```
$ objdump -Mintel -dS main.o
main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
extern void hello(void);

int main(void) {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   48 83 ec 10             sub    rsp,0x10
   8:   c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  hello();
   f:   e8 00 00 00 00          call   14 <main+0x14>
  return 0;
  14:   31 c0                   xor    eax,eax
  16:   48 83 c4 10             add    rsp,0x10
  1a:   5d                      pop    rbp
  1b:   c3                      ret
```

main.cで記述したC言語のソースコードが含まれているのがわかりますか？先ほど clang に `-g` オプションをつけてコンパイルしたおかげで、オブジェクトファイルにデバッグ情報が含まれています。`objdump` に `-S` オプションを付けることで、このデバッグ情報を読み取って、元のソースコードを合わせて閲覧することが可能になっているわけです。

注目していただきたいのは、 `hello` 関数の呼び出し部分です。 `call 14 <main+0x14>` という表示がありますね。ここがhello関数の呼び出し部分です。

ところで、`main+0x14` って何でしょうか？参考程度に、実行形式ファイルである `a.out` の部分と比較してみましょう。

| オブジェクトファイル `main.o` | 実行形式ファイル `a.out` |
| ------------------------- | ---------------------- |
| `call 14 <main+0x14>`     | `call 1160 <hello>`    |



## リンカの役割

さて、リンカの役割について見ていきましょう。リンクという作業は、その名の通り複数のオブジェクトファイルやライブラリを結合するという作業が主になります。

